package matrixandPriorityArray;

public class Array_Shortest_Path extends Main {
	static final int num_Vertices = size;  //max number of vertices in graph
	int pi[] = new int[size];
    // find a vertex with minimum distance
    int minDistance(int path_array[], Boolean S[])   { 
        // Initialize min value 
        int min = Integer.MAX_VALUE, min_index = -1; 
        for (int v = 0; v < num_Vertices; v++) 
            if (S[v] == false && path_array[v] <= min) { 
                min = path_array[v]; 
                min_index = v; 
                pi[v]=v;
            } 
   
        return min_index; 
    }
     // print the array of distances (path_array)
        void printMinpath(int path_array[])   { 
            System.out.println("Vertex# \t Minimum Distance from Source"); 
            for (int i = 0; i < num_Vertices; i++) 
                System.out.println(i + " \t\t\t " + path_array[i] +"\t"); 
        }
        
    // Implementation of Dijkstra's algorithm for graph (adjacency matrix) 
        void algo_dijkstra(int graph[][], int src_node)  { 
            int path_array[] = new int[num_Vertices]; // The output array. dist[i] will hold 
            // the shortest distance from src to i 
       
            // spt (shortest path set) contains vertices that have shortest path 
            Boolean S[] = new Boolean[num_Vertices]; 
       
            // Initially all the distances are INFINITE and stpSet[] is set to false 
            for (int i = 0; i < num_Vertices; i++) { 
                path_array[i] = Integer.MAX_VALUE; 
                S[i] = false; 
            } 
       
            // Path between vertex and itself is always 0 
            path_array[src_node] = 0; 
       // now find shortest path for all vertices  
            for (int count = 0; count < num_Vertices - 1; count++) { 
                // call minDistance method to find the vertex with min distance
                int u = minDistance(path_array, S); 
                  // the current vertex u is processed
                S[u] = true; 
                  // process adjacent nodes of the current vertex
                for (int v = 0; v < num_Vertices; v++) 
       
                    // if vertex v not in S then update it  
                    if (!S[v] && graph[u][v] != 0 && path_array[u] != 
                                Integer.MAX_VALUE && path_array[u] 
                                + graph[u][v] < path_array[v]) 
                                path_array[v] = path_array[u] + graph[u][v]; 
            } 
       
            // print the path array 
            printMinpath(path_array); 
        } 
}
